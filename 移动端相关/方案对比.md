### 为什么需要跨端
动态化内容需求增大。当需求发生变化时，纯原生应用需要通过版本升级来更新内容，但应用上架、审核是需要周期的，这个周期对高速变化的互联网时代来说是很难接受的，所以，对应用动态化 (不发版也可以更新应用内容) 的需求就变得迫在眉睫了。
业务需求变化快，开发成本变大。由于原生开发一般都要维护 Android、iOS 两个开发团队，版本迭代时，无论人力成本还是测试成本都会变大。
针对原生开发面临的问题，人们一直都在努力寻找好的解决方案，然而时至今日，已经存在很多跨平台框架 (注意，本书中所指的“跨平台”若无特殊说明，即特指 Android 和 iOS 两个平台)，根据其原理，主要可分为如下三类。

H5(HTML5)+ 原生 ( Cordova、 Tonic、微信小程序)。
Javascript 开发 + 原生渲染 ( React Native、Weex、uni-app)。
自绘 U+ 原生 ( QT Mobile、 Flutter)

### 5+ 
通过浏览器webView嵌入app中去掉地址栏等渲染H5页面，系统api通过JSBridge来调用。
H5 部分就可以随时改变而不用发版，动态化需求得到满足 ; 同时，由于 H5 代码只需要一次开发，就能同时在 Android 和 iOS 两个平台上正常运行，这也可以降低开发成本，也就是说，H5 部分的功能越多，开发成本就越小。我们称这种 H5+ 原生的开发模式为混合开发，对于采用混合模式开发的 APP，我们称之为混合应用或 Hybrid APP，如果一个应用的大多数功能都是采用 H5 实现的话，我们称其为 Web APP。

### react-native
通过jscore 建立的jsbridge来调用原生接口，把jsx转为原生组件渲染。  js开发+原生渲染
JavaScriptCore负责JS代码解释执行  
ReactJS负责描述和管理VirtualDom,指挥原生组件进行绘制和更新，同时很多计算逻辑也在js里面进行。ReactJS自身是不直接绘制UI的，UI绘制是非常耗时的操作，原生组件最擅长这事情。  
Bridges用来翻译ReactJS的绘制指令给原生组件进行绘制，同时把原生组件接收到的用户事件反馈给ReactJS。


### flutter
Flutter 与用于构建移动应用程序的其他大多数框架不同，因为 Flutter 既不使用 Webview，也不使用操作系统的原生控件。相反， Flutter 使用自己的高性能渲染引擎来绘制 Widget。这样不仅可以保证在 Android 和 iOS 上 UI 的一致性，而且可以避免因对原生控件依赖而带来的限制及高昂的维护成本
Flutter 使用 ska 作为其 2D 渲染引擎，而不是调用原生接口。需要使用dart进行开发，从而避免了前面几种方案JSbridge使用的原生开发

### 小程序
使用的也是hybrid技术，小程序的渲染层和逻辑层分别由 2 个线程管理：视图层的界面使用了 WebView 进行渲染，逻辑层采用 JsCore 线程运行 JS脚本。

![架构图](https://image.fundebug.com/2019-05-16-003.jpeg)

逻辑层：创建一个单独的线程去执行 JavaScript，在这里执行的都是有关小程序业务逻辑的代码，负责逻辑处理、数据请求、接口调用等
视图层：界面渲染相关的任务全都在 WebView 线程里执行，通过逻辑层代码去控制渲染哪些界面。一个小程序存在多个界面，所以视图层存在多个 WebView 线程
JSBridge 起到架起上层开发与Native（系统层）的桥梁，使得小程序可通过API使用原生的功能，且部分组件为原生组件实现，从而有良好体验

#### 数据更新
1. 在渲染层把 WXML 转化成对应的 JS 对象。

2. 在逻辑层发生数据变更的时候，通过宿主环境提供的 setData 方法把数据从逻辑层传递到 Native，再转发到渲染层。

3. 经过对比前后差异，把差异应用在原来的 DOM 树上，更新界面。


[小程序运行机制 https://blog.fundebug.com/2019/05/17/about-wechat-miniprogram-principle/](https://blog.fundebug.com/2019/05/17/about-wechat-miniprogram-principle/)
