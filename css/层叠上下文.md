# 概念
层叠上下文元素比非层叠上下文元素，在z轴上更有优先级，表现为离屏幕更近。  
层叠上下文中的每个元素都有一个层叠水平，决定了同一个层叠上下文中的元素在z轴上的显示顺序。  

# 产生方式
1. html根元素，根层叠上下文（自动生成）
2. 定位元素（普通元素设置position为非static后），并设置z-index为具体数值（非auto）
3. 一些css3新属性：
   1. opacity不为1
   2. transform不为none
   3. 父元素设置display:flex | inlin-flex，子元素的z-index不为auto（子元素为层叠上下文元素）——两个需要配合使用才能达到效果
   4. filter（滤镜）值不为none
   5. mix-blend-mode（混合模式）不为normal
   6. isolation（隔离）值为isolate
   7. position:fixed声明（不需要z-index辅助）——仅在blink/webkit浏览器内核上
   8. will-change属性（让浏览器预准备加速渲染）为上面的任意值
   9. 元素的-webkit-overflow-scrolling属性为touch

# 特点
+ 层叠上下文可以嵌套，组合成一个分层次的层叠上下文
+ 每个层叠上下文和兄弟元素独立，当进行层叠变化或渲染时，只需要考虑后代元素。
+ 每个层叠上下文都是自成体系的，当元素的内容被层叠后，整个元素被认为是在父层的层叠顺序中。

# 七阶层叠水平（从低到高）
**作用**：规范元素重叠时的呈现规则。
1. 层叠上下文元素的background/border——装饰——注意，是层叠上下文元素，也就是由上述3中方式创建层叠上下文的那个元素
2. 负z-index
3. 块：block——布局
4. 浮动：float——布局
5. 内联：inline/inline-block——内容，是最主要的实体；（img是inline-block）
6. z-index:auto 或 z-index:0 或 不依赖z-index的层叠上下文（css3新属性产生的）——0 和 auto的区别：0会新建层叠上下文，auto不会（IE7存在问题，仍会创建）
7. 正z-index  

**原因**：像border/background属于装饰元素的属性，块级元素和浮动元素一般用来页面布局，而网页设计之初最重要的就是文字内容（内联），所以在发生层叠时会优先显示文字内容，保证其不被覆盖。
**注意**：所有元素都有层叠水平，包括普通元素，包括层叠上下文元素。


# z-index
**取值**：z-index: auto(默认) | 整数值(支持负值) | inherit
**作用**：用来调整*定位元素*（position不为static）及其子元素在 z 轴上的层叠顺序，通常z-index值大的会覆盖小的。
**特点**：
1. 支持负值
2. 支持css3 animation动画（动画里面使用z-index）
3. 非css3，需要配合定位元素才能使用：
   + 如果定位元素未发生嵌套：
     +  后来居上
     +  z-index大的在上面
   +  如果定位元素发生嵌套：
      +  祖先元素优先——前提是，祖先的z-index不为auto

**生效条件**：必须要设置*定位属性*（设置了position值但不为static时）（或者一些 *CSS3 属性*），设置后，z-index：auto就会生效；否则不会起任何作用。——首先必须要是支持设置z-index的元素

# 比较两个DOM的显示顺序
1. 如果是在相同的层叠上下文，按照层叠水平的规则来显示元素
   1. 层叠水平的比较，仅在相同层叠上下文的元素中才有意义。
   2. 当两个元素层叠水平相同的时候，这时候就要遵循下面两个准则：
      1. 后来居上原则
      2. z-index 大的在上
2. 如果是在不同的层叠上下文中，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下这个两个元素所在的局部层叠上下文的层叠水平。

**注释**：
+ 父元素如果没有创建新的层叠上下文，那它和它的子元素是处于同一个层叠上下文的，这个层叠上下文是上一层的共同层叠上下文。使用七阶层叠水平来判断他俩谁在上面。
+ 如果父元素创建了局部层叠上下文（新的层叠上下文），那他们也是处于同一个层叠上下文中的，只是这个层叠上下文是由父元素创建的局部层叠上下文。

![stacking-context](https://pic1.zhimg.com/80/v2-73d66f72d07723dba8288af99c863d2c_720w.jpg)
+ 假设 Root、ParentX、ChildX 均为层叠上下文元素
+ 则A、B、ChildB，处于同一层叠上下文（ChildB）
+ A要和C或者ChildA比较，需要先找到共同的祖先层叠上下文（ParentB），然后比较祖先层叠上下文下两个元素所在的局部层叠上下文比较层叠水平(这里就是 ChildA 和 ChildB 去比较)
+ 同理，如果A和D比较，则只需要比较ParentA和ParentB的层叠水平。

# 最佳实践
1. 最小化影响原则：避免z-index嵌套层级关系混乱
   1. 避免使用定位属性
   2. 定位属性从大容器平级分为私有小容器
2. 不犯二准则：
   1. 对于非浮层元素（浮层元素比如弹框），避免设置 z-index 值
   2. z-index 值没有任何道理需要超过 2 ——应该合理利用层叠上下文层叠水平以及后来居上准则来实现
3. 组件层级计数器
   1. 避免浮层组件被z-index覆盖的问题
   2. 对于浮层元素，可以通过 JS 获取body下子元素的最大z-index值，然后给浮层元素的z-index设置最大值+1，确保弹框组件能显示在最上面。
      1. DOM.style.zIndex值只能获取到内联样式中的z-index值；要找到元素的真实 css 属性，就必须使用 window.getComputedStyle() 方法
      2. 获取页面最大z-index方法：
      ```
      方法一：
      var arr = [...document.body.querySelectAll('*')].map(e => +window.getComputedStyle(e).zIndex || 0)
      return arr.length ? Math.max(...arr) : 0
      方法二：
      return [...document.all].reduce((r, e) => Math.max(r, +window.getComputedStyle(e).zIndex || 0), 0)
      ```
4. 可访问性隐蔽：
   1. 指人肉眼不可见，但是可以通过设备识别。如一个元素定位到屏幕之外。
   2. 可以通过设置z-index为负值元素，可以实现在层叠上下文的背景之上但是在其他元素之下。比如想要覆盖默认的按钮样式时，可以设置按钮的z-index为负数使其不可见，再通过label设置想要的样式。
